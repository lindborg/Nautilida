package nautilida.players {	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.utils.*;	import nautilida.elements.*;	import nautilida.opsticals.*;	import nautilida.environments.*;	import nautilida.levels.*;	import nautilida.points.*;	import nautilida.enemies.*;	import nautilida.weapons.*;		public class Player extends Element {		public var left:Number = 0;		public var right:Number = 0;		public var up:Number = 0;		public var down:Number = 0;						public var speedLeft:Number = 0;		public var speedRight:Number = 0;		public var speedUp:Number = 0;		public var speedDown:Number = 0;						public var environment:Environment;		public var hitarea:MovieClip;				public var opstical:Opstical;		public var opsticalOffsetX:Number = 0;		public var opsticalOffsetY:Number = 0;				public var isAccLeft:Boolean = false;		public var isAccRight:Boolean = false;		public var isAccUp:Boolean = false;		public var isAccDown:Boolean = false;				public var previousState:String = 'up';				public function Player() {			gotoAndStop(1);			addEventListener(Event.ADDED_TO_STAGE,onAdded);		}				// EVENTS //				private function onAdded(event:Event):void {			addEventListener(Event.REMOVED_FROM_STAGE,onRemoved);			addEventListener(Event.ENTER_FRAME,onEnterFrame);			stage.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP,onKeyUp);		}		private function onRemoved(event:Event):void {			removeEventListener(Event.REMOVED_FROM_STAGE,onRemoved);			removeEventListener(Event.ENTER_FRAME,onEnterFrame);			stage.removeEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);			stage.removeEventListener(KeyboardEvent.KEY_UP,onKeyUp);		}		private function onKeyDown(event:KeyboardEvent):void {			switch(event.keyCode) {				case Keyboard.LEFT: isAccLeft = true; break;				case Keyboard.RIGHT: isAccRight = true; break;				case Keyboard.UP: isAccUp = true; break;				case Keyboard.DOWN: isAccDown = true; break;				case Keyboard.SPACE: shoot(); break;			}			accelerate();		}		private function onKeyUp(event:KeyboardEvent):void {			switch(event.keyCode) {				case Keyboard.LEFT: isAccLeft = false; break;				case Keyboard.RIGHT: isAccRight = false; break;				case Keyboard.UP: isAccUp = false; break;				case Keyboard.DOWN: isAccDown = false; break;			}		}		private function onEnterFrame(event:Event):void {			if(platform.isLevel) {				if(isAtEnd) {					level.next();				}				else if(isOutOfBounds) {					die();				}				else {					if(environment === null) { environment = level.environment; }										accelerate();										left = speedLeft;					right = speedRight;					up = speedUp;					down = speedDown+environment.gravity;										hitTest();					bindToOpstical();					animate();					render();					deaccelerate();				}			}		}				// GET //				public function get currentStateClip():MovieClip {			var stateClip:MovieClip = getChildAt(0) as MovieClip;						if(stateClip == null) {				return new MovieClip();			}			return stateClip;		}		public function get currentState():String {			var state:String = 'up';						if(up || down) { state = 'jump'; }			else if(left || right) { state = 'walk'; }			else if(speedDown) { state = 'down'; }						return state;		}		public function get isAtEnd():Boolean {			return (level.boundRight < x);		}				// EVALUATE //				private function hitTest():void {			var hitTestClip:MovieClip = hitarea;						for(var i:uint = 0; parent.numChildren > i; i++) {				var child:DisplayObject = parent.getChildAt(i);				if(child is Enemy) {					if(child.hitTestObject(hitTestClip)) {						var enemy:Point = child as Enemy;						die();						break;					}				}				if(child is Point) {					if(child.hitTestObject(hitTestClip)) {						var point:Point = child as Point;						point.achive();					}				}				if(child is Opstical) {					if(down >= up && child !== opstical) {						if(Math.abs(child.y-y) < 20 && Math.abs(x-child.x) <= (child.width/2)) {							if(child.hitTestObject(hitTestClip)) {								opstical = child as Opstical;								opsticalOffsetX = x-opstical.x;							}						}					}				}				if(child is Environment) {					if(child.hitTestObject(hitTestClip)) {						environment = child as Environment;					}				}			}		}		private function bindToOpstical():void {			if(opstical !== null) {				x = opstical.x+opsticalOffsetX;				y = opstical.y+opsticalOffsetY;				environment.jumps = environment.maxJumps;				down = up = 0;			}		}		private function animate():void {			if(previousState != currentState) {				previousState = currentState;				gotoAndStop(currentState);			}		}		private function render():void {			x += right;			x -= left;			y += down;			y -= up;						x = Math.max(0,x);						if(left > right) {				scaleX = -1;			}			else if(left < right) {				scaleX = 1;							}		}		private function accelerate():void {			if(isAccLeft || isAccRight || isAccUp || isAccDown) {				if(isAccLeft) {					speedLeft = environment.accLeft;					clearOpstical();				}				if(isAccRight) {					speedRight = environment.accRight;					clearOpstical();				}				if(isAccUp) {					if(environment.jumps) {						speedUp = environment.accUp;						environment.jumps--;						clearOpstical();					}				}				if(isAccDown) {					speedDown = environment.accDown;				}			}		}		override public function die():void {			clearOpstical();			explode();			level.reset();		}		private function clearOpstical():void {			opstical = null;		}		private function deaccelerate():void {			if(Math.abs(speedLeft-environment.breakLeft) <= Math.abs(environment.breakLeft)) { speedLeft = 0; }			else if(speedLeft < 0) { speedLeft += environment.breakLeft; }			else if(speedLeft > 0) { speedLeft -= environment.breakLeft; }						if(Math.abs(speedRight-environment.breakRight) <= Math.abs(environment.breakRight)) { speedRight = 0; }			else if(speedRight < 0) { speedRight += environment.breakRight; }			else if(speedRight > 0) { speedRight -= environment.breakRight; }						if(Math.abs(speedUp-environment.breakUp) <= Math.abs(environment.breakUp)) { speedUp = 0; }			else if(speedUp < 0) { speedUp += environment.breakUp; }			else if(speedUp > 0) { speedUp -= environment.breakUp; }						if(Math.abs(speedDown-environment.breakDown) <= Math.abs(environment.breakDown)) { speedDown = 0; }			else if(speedDown < 0) { speedDown += environment.breakDown; }			else if(speedDown > 0) { speedDown -= environment.breakDown; }		}		private function shoot():void {			var weapon:Weapon = new Bullet();						weapon.align(this);			weapon.x += hitarea.x;			weapon.y += hitarea.y;			weapon.directionX = scaleX;						level.addWeapon(weapon);		}	}}